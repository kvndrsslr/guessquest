/**
 * Ported from Zig implementation of bit-level IO with Little Endian packing.
 * LLM-generated by Gemini Pro 3 Preview.
 */

const LOW_BIT_MASK = [
	0b00000000, 0b00000001, 0b00000011, 0b00000111, 0b00001111, 0b00011111, 0b00111111, 0b01111111,
	0b11111111
];

export class MessageWriter {
	#buf: Uint8Array;
	#offset = 0;

	// Zig Port: 'bits' and 'count' state machine
	#bitBuffer = 0; // The u8 accumulator
	#bitCount = 0; // How many bits are currently in the accumulator

	constructor(initialSize = 2024) {
		this.#buf = new Uint8Array(initialSize);
	}

	/**
	 * Zig-derived addBits helper.
	 * Adds bits to the internal accumulator, not the byte array.
	 */
	#addBits(bits: number, num: number): void {
		const maskedBits = bits & LOW_BIT_MASK[num];
		// Little Endian: pack starting in least significant part
		this.#bitBuffer |= maskedBits << this.#bitCount;
		this.#bitCount += num;
	}

	/**
	 * Pushes a full byte to the array, handling bounds checking.
	 */
	#pushByte(byte: number): void {
		if (this.#offset >= this.#buf.length) {
			throw new Error('MessageWriter buffer overflow');
		}
		this.#buf[this.#offset++] = byte;
	}

	/**
	 * Writes bits using the Zig Little Endian logic.
	 * Supports boolean, number, or bigint.
	 */
	writeBits(num: number, value: number | boolean | bigint): void {
		let input: bigint;

		if (typeof value === 'boolean') {
			input = value ? 1n : 0n;
		} else {
			input = BigInt(value);
		}

		let inCount = num;

		// 1. Fill the existing partial buffer if it exists
		if (this.#bitCount > 0) {
			const bitsFree = 8 - this.#bitCount;

			// If we can't fill the buffer, just add what we have and return
			if (num < bitsFree) {
				this.#addBits(Number(input), num);
				return;
			}

			// Fill the rest of the buffer
			this.#addBits(Number(input), bitsFree);
			input >>= BigInt(bitsFree);
			inCount -= bitsFree;

			// Flush the full byte
			this.#pushByte(this.#bitBuffer);
			this.#bitBuffer = 0;
			this.#bitCount = 0;
		}

		// 2. Write as many full bytes as we can directly
		while (inCount >= 8) {
			this.#pushByte(Number(input & 0xffn));
			input >>= 8n;
			inCount -= 8;
		}

		// 3. Save any remaining bits in the accumulator
		if (inCount > 0) {
			this.#addBits(Number(input), inCount);
		}
	}

	/**
	 * Flushes any remaining bits in the accumulator to the byte array.
	 * Used before writing aligned data (like strings) or finishing.
	 */
	alignToByte(): void {
		if (this.#bitCount > 0) {
			this.#pushByte(this.#bitBuffer);
			this.#bitBuffer = 0;
			this.#bitCount = 0;
		}
	}

	writeString(value: string): void {
		this.alignToByte();
		const encodedString = new TextEncoder().encode(value);

		// Ensure space exists
		if (this.#offset + encodedString.length + 1 > this.#buf.length) {
			throw new Error('MessageWriter buffer overflow on string write');
		}

		this.#buf.set(encodedString, this.#offset);
		this.#offset += encodedString.length;
		this.#buf[this.#offset++] = 0; // Null terminator
	}

	finalize(): ArrayBuffer {
		this.alignToByte();
		// Return a copy of the used portion
		return this.#buf.slice(0, this.#offset).buffer;
	}
}

export class MessageReader {
	#buf: Uint8Array;
	#offset = 0;

	// Zig Port: 'bits' and 'count' state
	#bitBuffer = 0; // The u8 accumulator
	#bitCount = 0; // How many bits remain in the accumulator

	constructor(buf: ArrayBuffer) {
		this.#buf = new Uint8Array(buf);
	}

	// Helper to get next byte securely
	#nextByte(): number {
		if (this.#offset >= this.#buf.length) {
			throw new Error('EndOfStream');
		}
		return this.#buf[this.#offset++];
	}

	// Zig-derived removeBits helper
	#removeBits(num: number): number {
		if (num === 8) {
			this.#bitCount = 0;
			return this.#bitBuffer;
		}

		const keep = this.#bitCount - num;

		// Little Endian: take bits from the low end
		const resultBits = this.#bitBuffer & LOW_BIT_MASK[num];
		// Move high bits down
		this.#bitBuffer >>= num;

		this.#bitCount = keep;
		return resultBits;
	}

	/**
	 * Reads `num` bits.
	 * Use generic T to cast safely. If T is unused, returns number or bigint depending on size.
	 */
	readBits<T = number>(num: number, t?: (n: number | bigint) => T): T {
		// Optimization: if we already have enough bits in buffer
		if (num <= this.#bitCount) {
			const val = this.#removeBits(num);
			return t ? t(val) : (val as unknown as T);
		}

		let outCount = this.#bitCount;
		let out: bigint = BigInt(this.#removeBits(this.#bitCount));

		// Read full bytes needed
		const fullBytesLeft = Math.floor((num - outCount) / 8);

		for (let i = 0; i < fullBytesLeft; i++) {
			const byte = this.#nextByte();
			// Little Endian: subsequent bytes are more significant
			out |= BigInt(byte) << BigInt(outCount);
			outCount += 8;
		}

		const bitsLeft = num - outCount;

		if (bitsLeft > 0) {
			const finalByte = this.#nextByte();
			// Little Endian: take bottom bits of final byte, shift them up
			out |= BigInt(finalByte & LOW_BIT_MASK[bitsLeft]) << BigInt(outCount);

			// Store remaining high bits in buffer
			this.#bitBuffer = finalByte >> bitsLeft;
			this.#bitCount = 8 - bitsLeft;
		} else {
			// We landed exactly on a byte boundary
			this.#bitCount = 0;
			this.#bitBuffer = 0;
		}

		// Return number if small enough (for convenience), else bigint
		const result = num <= 32 ? Number(out) : out;

		if (t) {
			return t(result);
		}
		return result as unknown as T;
	}

	readBitsArray<T = number>(num: number, length: number, t?: (n: number | bigint) => T): T[] {
		const arr: T[] = [];
		for (let i = 0; i < length; i++) {
			arr.push(this.readBits(num, t));
		}
		return arr;
	}

	alignToByte(): void {
		this.#bitCount = 0;
		this.#bitBuffer = 0;
	}

	#findNextZeroTerminator(start: number): number {
		for (let i = start; i < this.#buf.length; i++) {
			if (this.#buf[i] === 0) {
				return i;
			}
		}
		return -1;
	}

	readString(): string {
		this.alignToByte();
		const term = this.#findNextZeroTerminator(this.#offset);
		if (term === -1) throw new Error('EndOfStream checking for string terminator');

		const result = new TextDecoder().decode(this.#buf.subarray(this.#offset, term));
		this.#offset = term + 1;
		return result;
	}

	readStringArray(length: number): string[] {
		const strings: string[] = [];
		for (let i = 0; i < length; i++) {
			strings.push(this.readString());
		}
		return strings;
	}
}
